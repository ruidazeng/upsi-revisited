// Cryptographic Tree Implementation
// Based on Microsoft's Merkle Tree

// Finished Tasks:
// 1. Node structures (TODO - structures of the elements/contents)
// encryption under el gamal or paillier (ecc points)
// additon - element/payload (element under private key, payload under paillier)
// cost of loading bytes into elliptical curve
// 2. Tree structures (TODO - encryption of nodes)
// Look at representation, bit operation, identify nodes in the path
// Array/List representation of the tree (binary)
// Efficiency
// 3. Hash structures (Figure out if this is acceptable? If not replace)
// Add OpenSSL AES (agree on randomly generated key)
// Use another key to generate random path: random location to allocate, random path different key (private
// Shared key - Private key
// Path - seed needs to be randomly sampled everytime
// - Ruida

// TODO:
// 1. Finish writing get_path()
// 2. Finishwriting insert()
// 3. Add UpdateTree functionality (need to be multiparty)
// 4. Elements need to be encrypted (using AES or similar)
// - Ruida
// Addition only - all functionalities
// Addition/Deletion - Sum

// Questions:
// 1. How to achieve multiparty?
// 2. Seralization/Deserialization of the tree
// take all points, into new seralize path, send off
// receive seraizlie path, put into tree

#include <array>
#include <cassert>
#include <cmath>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <functional>
#include <list>
#include <memory>
#include <sstream>
#include <stack>
#include <vector>


// Cryptographic Tree Structures

 class TreeT
  {
  protected:
    /// @brief The structure of tree nodes
    struct Node
    {
      /// @brief Constructs a new tree node
      static Node* make()
      {
        auto r = new Node();
        r->left = r->right = nullptr;
        r->update_sizes();
        return r;
      }

      /// @brief Constructs a new tree node
      /// @param left The left child of the new node
      /// @param right The right child of the new node
      static Node* make(Node* left, Node* right)
      {
        auto r = new Node();
        r->left = left;
        r->right = right;
        r->update_sizes();
        return r;
      }

      ~Node()
      {
        delete (left);
        delete (right);
      }
    
          /// @brief Updates the tree size and height of the subtree under a node
      void update_sizes()
      {
        if (left && right)
        {
          depth = std::max(left->depth, right->depth) + 1;
        }
        else
          depth = 1;
      }

      /// @brief The left child of the node
      Node* left;

      /// @brief The right child of the node
      Node* right;

      /// @brief The depth of the subtree
      uint8_t depth;
    };

    // Tree
    /// @brief Current root node of the tree
    Node* _root = nullptr;

    /// @brief Current stash node of the tree
    Node* _stash = nullptr;

    /// @brief The node size of the tree
    uint8_t node_size;

    /// @brief The max stash of the subtree
    uint8_t max_stash;

  public:

    /// @brief Constructs an empty tree
    TreeT() {}

    /// @brief Copies a tree
    TreeT(const TreeT& other)
    {
      *this = other;
    }

    /// @brief Constructs a tree containing one root
    /// @param node_size the node size of the tree
    TreeT(const uint8_t node_size)
    {
        this->node_size = node_size;
        this->max_stash = 0;
        Node* root = make();
        Node* stash = make();
        // TODO: Do I need to call insert()?
        this->_root = root;
        this->_stash = stash;
    }

    /// @brief Deconstructor
    ~TreeT()
    {
      delete (_root);
      // TODO: Iterative deletion
    }

    /// @brief Inserts an element into the tree
    /// @param element element to be inserted
    void insert(const auto element)
    {
        // TODO: auto insertion
    }

    /// @brief Sender adds input element to encrypted tree with stash held
    /// by receiver. Sender has secret key and both parties have the public key
    /// @param x input element
    /// @param p optional payload
    /// @param sk secret key
    /// @param D encrypted tree
    /// @param S stash
    /// @param pk public key
    void updateTree()
    {
        // TODO
    }

    /// @brief Walks along the path from the root of a tree to a leaf
    /// @param index The leaf index to walk to
    /// @param update Flag to enable re-computation of node fields (like
    /// subtree size) while walking
    /// @param f Function to call for each node on the path; the Boolean
    /// indicates whether the current step is a right or left turn.
    /// @return The final leaf node in the walk
    inline Node* walk_to(
      size_t index, bool update, const std::function<bool(Node*&, bool)>&& f)
    {
      if (index < min_index() || max_index() < index)
        throw std::runtime_error("invalid leaf index");

      compute_root();

      assert(index < _root->size);

      Node* cur = _root;
      size_t it = 0;
      if (_root->height > 1)
        it = index << (sizeof(index) * 8 - _root->height + 1);
      assert(walk_stack.empty());

      for (uint8_t height = _root->height; height > 1;)
      {
        assert(cur->invariant());
        bool go_right = (it >> (8 * sizeof(it) - 1)) & 0x01;
        if (update)
          walk_stack.push_back(cur);
        if (cur->height == height)
        {
          if (!f(cur, go_right))
            continue;
          cur = (go_right ? cur->right : cur->left);
        }
        it <<= 1;
        height--;
      }

      if (update)
        while (!walk_stack.empty())
        {
          walk_stack.back()->update_sizes();
          walk_stack.pop_back();
        }

      return cur;
    }

    /// @brief Extracts the path from a leaf index to the root of the tree
    /// @param index The leaf index of the path to extract
    /// @return The path
    std::shared_ptr<Path> path(size_t index)
    {
      statistics.num_paths++;
      std::list<typename Path::Element> elements;

      walk_to(index, false, [&elements](Node* n, bool go_right) {
        typename Path::Element e;
        e.hash = go_right ? n->left->hash : n->right->hash;
        e.direction = go_right ? Path::PATH_LEFT : Path::PATH_RIGHT;
        elements.push_front(std::move(e));
        return true;
      });

      return std::make_shared<Path>(
        leaf_node(index)->hash, index, std::move(elements), max_index());
    }

  };