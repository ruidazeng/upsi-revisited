// Cryptographic Tree Implementation
// Based on Microsoft's Merkle Tree

// Finished Tasks:
// 1. Node structures (TODO - structures of the elements/contents)
// encryption under el gamal or paillier (ecc points)
// additon - element/payload (element under private key, payload under paillier)
// cost of loading bytes into elliptical curve
// 2. Tree structures (TODO - encryption of nodes)
// Look at representation, bit operation, identify nodes in the path
// Array/List representation of the tree (binary)
// Efficiency
// 3. Hash structures (Figure out if this is acceptable? If not replace)
// Add OpenSSL AES (agree on randomly generated key)
// Use another key to generate random path: random location to allocate, random path different key (private)
// Shared key - Private key
// Path - seed needs to be randomly sampled everytime
// - Ruida

// TODO:
// 1. Finish writing get_path()
// 2. Finishwriting insert()
// 3. Add UpdateTree functionality (need to be multiparty)
// 4. Elements need to be encrypted (using AES or similar)
// - Ruida
// Addition only - all functionalities
// Addition/Deletion - Sum

// Questions:
// 1. How to achieve multiparty?
// 2. Seralization/Deserialization of the tree
// take all points, into new seralize path, send off
// receive seraizlie path, put into tree

#include <array>
#include <cassert>
#include <cmath>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <functional>
#include <list>
#include <memory>
#include <sstream>
#include <stack>
#include <vector>


// Cryptographic Tree Structures

 class TreeT
  {
  protected:
    /// @brief The structure of tree nodes
    struct Node
    {
      /// @brief Constructs a new tree node
      static Node* make()
      {
        auto r = new Node();
        r->left = r->right = nullptr;
        r->update_sizes();
        return r;
      }

      /// @brief Constructs a new tree node
      /// @param left The left child of the new node
      /// @param right The right child of the new node
      static Node* make(Node* left, Node* right)
      {
        auto r = new Node();
        r->left = left;
        r->right = right;
        r->update_sizes();
        return r;
      }

      ~Node()
      {
        delete (left);
        delete (right);
      }
    
          /// @brief Updates the tree size and height of the subtree under a node
      void update_sizes()
      {
        if (left && right)
        {
          depth = std::max(left->depth, right->depth) + 1;
        }
        else
          depth = 1;
      }

      /// @brief The left child of the node
      Node* left;

      /// @brief The right child of the node
      Node* right;

      /// @brief The depth of the subtree
      uint8_t depth;
    };

    // Tree
    /// @brief Current root node of the tree
    Node* _root = nullptr;

    /// @brief Current stash node of the tree
    Node* _stash = nullptr;

    /// @brief The node size of the tree
    uint8_t node_size;

    /// @brief The max stash of the subtree
    uint8_t max_stash;

  public:

    /// @brief Constructs an empty tree
    TreeT() {}

    /// @brief Copies a tree
    TreeT(const TreeT& other)
    {
      *this = other;
    }

    /// @brief Constructs a tree containing one root
    /// @param node_size the node size of the tree
    TreeT(const uint8_t node_size)
    {
        this->node_size = node_size;
        this->max_stash = 0;
        Node* root = make();
        Node* stash = make();
        // TODO: Do I need to call insert()?
        this->_root = root;
        this->_stash = stash;
    }

    /// @brief Deconstructor
    ~TreeT()
    {
      delete (_root);
      // TODO: Iterative deletion
    }

    /// @brief Inserts an element into the tree
    /// @param element element to be inserted
    void insert(const auto element)
    {
        // TODO: auto insertion
    }

    /// @brief Sender adds input element to encrypted tree with stash held
    /// by receiver. Sender has secret key and both parties have the public key
    /// @param x input element
    /// @param p optional payload
    /// @param sk secret key
    /// @param D encrypted tree
    /// @param S stash
    /// @param pk public key
    void updateTree()
    {
        // TODO
    }

    /// @brief Walks along the path from the root of a tree to a leaf
    /// @param index The leaf index to walk to
    /// @param update Flag to enable re-computation of node fields (like
    /// subtree size) while walking
    /// @param f Function to call for each node on the path; the Boolean
    /// indicates whether the current step is a right or left turn.
    /// @return The final leaf node in the walk
    inline Node* walk_to(
      size_t index, bool update, const std::function<bool(Node*&, bool)>&& f)
    {
      if (index < min_index() || max_index() < index)
        throw std::runtime_error("invalid leaf index");

      compute_root();

      assert(index < _root->size);

      Node* cur = _root;
      size_t it = 0;
      if (_root->height > 1)
        it = index << (sizeof(index) * 8 - _root->height + 1);
      assert(walk_stack.empty());

      for (uint8_t height = _root->height; height > 1;)
      {
        assert(cur->invariant());
        bool go_right = (it >> (8 * sizeof(it) - 1)) & 0x01;
        if (update)
          walk_stack.push_back(cur);
        if (cur->height == height)
        {
          if (!f(cur, go_right))
            continue;
          cur = (go_right ? cur->right : cur->left);
        }
        it <<= 1;
        height--;
      }

      if (update)
        while (!walk_stack.empty())
        {
          walk_stack.back()->update_sizes();
          walk_stack.pop_back();
        }

      return cur;
    }

    /// @brief Extracts the path from a leaf index to the root of the tree
    /// @param index The leaf index of the path to extract
    /// @return The path
    std::shared_ptr<Path> path(size_t index)
    {
      statistics.num_paths++;
      std::list<typename Path::Element> elements;

      walk_to(index, false, [&elements](Node* n, bool go_right) {
        typename Path::Element e;
        e.hash = go_right ? n->left->hash : n->right->hash;
        e.direction = go_right ? Path::PATH_LEFT : Path::PATH_RIGHT;
        elements.push_front(std::move(e));
        return true;
      });

      return std::make_shared<Path>(
        leaf_node(index)->hash, index, std::move(elements), max_index());
    }

  };


  import random

class Node:
    def __init__(self, layer=0):
        self.values = []
        self.left = None
        self.right = None
        self.layer = layer

    def depth(self):
        if self.left is None:
            return 1
        return 1 + max(self.left(depth), self.right(depth))

class Tree:

    def __init__(self, node_size):
        self.root = Node()
        self.stash = Node()
        self.depth = self.root.layer
        self.size = 0

        self.node_size = node_size
        self.max_stash = 0

    def get_next_path(self):
        if self.size >= pow(2, self.depth) + 1:
            random.seed()
            fmt = "{0:0" + str(self.depth + 1) + "b}"
            return fmt.format(random.randrange(pow(2, self.depth + 1)))
        else:
            random.seed()
            fmt = "{0:0" + str(self.depth) + "b}"
            return fmt.format(random.randrange(pow(2, self.depth)))

    def insert(self, value):
        curr_path = self.get_next_path()
        nodes, stash = self.get_path(curr_path)

        values = set(stash.values + [value])
        for node in nodes:
            values |= set(node.values)
            node.values = []

        for i in range(len(curr_path), 0, -1):
            matches = [val for val in values if self.hash(val)[:i] == curr_path[:i]]
            nodes[i].values = matches[:self.node_size]
            values -= set(nodes[i].values)

        nodes[0].values = list(values)[:self.node_size]
        values -= set(nodes[0].values)
        stash.values = list(values)
        self.size += 1

        self.max_stash = max(self.max_stash, len(stash.values))

    def get_path(self, path):
        nodes = [self.root]
        current = self.root
        for choice in path:
            if current.left is None:
                current.left, current.right = Node(current.layer + 1), Node(current.layer + 1)
                self.depth = max(self.depth, current.left.layer)
            current = current.left if choice == "0" else current.right
            nodes.append(current)

        return nodes, self.stash

    def hash(self, value):
        random.seed(value)
        fmt = "{0:0" + str(self.depth) + "b}"
        return fmt.format(random.randrange(pow(2, self.depth)))