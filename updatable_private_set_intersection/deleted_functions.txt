#ifndef CryptoNode_H
#define CryptoNode_H

#include <array>
#include <cassert>
#include <cmath>
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <list>
#include <memory>
#include <sstream>
#include <stack>
#include <vector>

class CryptoNode
{
    private:
        // bool isRoot;
        // bool isLeaf;

        // int layer = 0;

        // int nodesize;
        // int nodeNumber; // 0 for root, -1 for stash
        // int parentNodeNumber;
        // int leftChildNodeNumber;
        // int rightChildNodeNumber;

        // decide format of content/payload - payload[i] corresponds to elements[i]
        // encryption under el gamal or paillier (ecc points)
        // additon - element/payload (element under private key, payload under paillier)
        std::vector<unsigned char*> content;
        std::vector<unsigned char*> payload;
        
        // void makeRoot();
        // void makeNotRoot();
        
    public:
        CryptoNode();
        // CryptoNode(int nodeNumber);
        // CryptoNode(int nodeNumber, std::vector<unsigned char> &content);
        // CryptoNode(int nodeNumber, std::vector<unsigned char> &payload);
        // CryptoNode(int nodeNumber, std::vector<unsigned char> &content, std::vector<unsigned char> &payload);

        // bool isRoot();
        // bool isLeaf();

        // void makeLeaf();
        // void makeNotLeaf();

        // int getNodeNumber();
        // int getParentNodeNumber();
        // int getLeftChildNodeNumber();
        // int getRightChildNodeNumberr();

        // std::vector<unsigned char*> getContent();
        // std::vector<unsigned char*> getPayload();

        // std::vector<unsigned char*> setContent(std::vector<unsigned char> &content);
        // std::vector<unsigned char*> setPayload(std::vector<unsigned char> &payload);
}

#endif

#include "crypto_node.h"

#include <array>
#include <cassert>
#include <cmath>
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <list>
#include <memory>
#include <sstream>
#include <stack>
#include <vector>

CryptoNode::CryptoNode() {};

// CryptoNode::CryptoNode(int nodeNumber) {
//     nodeNumber(nodeNumber);
//     // if (nodeNumber == 0): this->makeRoot();
// }

// CryptoNode::CryptoNode(int nodeNumber, std::vector<unsigned char> &content) {
//     nodeNumber(nodeNumber);
//     content(content);
//     // if (nodeNumber == 0): this->makeRoot();
// }

// CryptoNode::CryptoNode(int nodeNumber, std::vector<unsigned char> &payload) {
//     nodeNumber(nodeNumber);
//     payload(payload);
//     // if (nodeNumber == 0): this->makeRoot();
// }

// CryptoNode::CryptoNode(int nodeNumber, std::vector<unsigned char> &content, std::vector<unsigned char> &payload) {
//     nodeNumber(nodeNumber);
//     content(content);
//     payload(payload);
//     // if (nodeNumber == 0): this->makeRoot();
// }

// bool CryptoNode::isRoot() {
//     return this->isRoot;
// }

// bool CryptoNode::isLeaf() {
//     return this->isLeaf;
// }

// void CryptoNode::makeRoot() {
//     this->isRoot = true;
// }

// void CryptoNode::makeNotRoot() {
//     this->isRoot = false;
// }

// void CryptoNode::makeLeaf() {
//     this->isLeaf = true;
// }

// void CryptoNode::makeNotLeaf() {
//     this->isLeaf = false;
// }

// int CryptoNode::getNodeNumber() {
//     return this->nodeNumber;
// }

// // int CryptoNode::getParentNodeNumber() {
// //     return this->parentNodeNumber;
// // }

// // int CryptoNode::getLeftChildNodeNumber() {
// //     return this->leftChildNodeNumber;
// // }

// // int CryptoNode::getRightChildNodeNumberr() {
// //     return this->rightChildNodeNumber;
// // }

// std::vector<unsigned char*> CryptoNode::getContent() {
//     return this->content;
// }

// std::vector<unsigned char*> CryptoNode::getPayload() {
//     return this->payload;
// }

// std::vector<unsigned char*> CryptoNode::setContent(std::vector<unsigned char> &content) {
//     this->content = content;
//     return this->content;
// }

// std::vector<unsigned char*> CryptoNode::setPayload(std::vector<unsigned char> &payload) {
//     this->payload = payload;
//     return this->payload;
// }

#ifndef CryptoTree_H
#define CryptoTree_H

#include "crypto_node.h"
#include "util/hash.h"
#include <array>
#include <cassert>
#include <cmath>
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <list>
#include <memory>
#include <sstream>
#include <stack>
#include <vector>


class CryptoTree
{
    private:
        // Array list representation
        std::vector<CryptoNode> crypto_tree;

        // Current stash node of the tree
        std::vector<CryptoNode> stash;

        // Depth of the tree
        int depth = 0;
        
        // Size of the tree (including root node)
        int size = 0;

        // The node size of the tree
        int node_size;

        // The max stash of the subtree
        int max_stash = 0;

        // Helper function: generate zero or one
        std::string randomBinary();

    public:
        CryptoTree();

        CryptoTree(int node_size);

        // Add a new layer to the tree, expand the size of the vector
        void addNewLayer();

        // // Generate a number that corresponds to a leaf node
        // void generateLeaf();

        // // Generate a path based on content using hash, hashing the same content will result in the same path
        // std::string hashPath(int depth, std::vector<bytes*> content);

        // Generate a random path
        void getPath();

        // Generate a path based on an element
        void getPath(int element);

        void replacePath();

        // Insert a new node
        void insert();

        // Update Tree (sender)
        void senderUpdateTree();

        // Update Tree (receiver)
        void receiverUpdateTree();
};

#endif

#include "crypto_tree.h"

#include <array>
#include <cassert>
#include <cmath>
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <list>
#include <memory>
#include <sstream>
#include <stack>
#include <vector>


CryptoTree::CryptoTree() {};

CryptoTree::CryptoTree(int node_size) {
    node_size(node_size);
    
    // Index for root node is 0, index for stash node is -1
    CryptoNode root = CryptoNode::CryptoNode(0);
    CryptoNode stash = CryptoNode::CryptoNode(-1);

    this->crypto_tree.push_back(root);
    this->size += 1;
}

void CryptoTree::addNewLayer() {
    this->depth += 1;
    int new_size = std::pow(2, this->depth + 1) - 1
    this->crypto_tree.resize(new_size);
}

// int CryptoTree::generateLeaf() {
//     int lower_bound = 2 * this->depth - 1;
//     int upper_bound = 2 * (this->depth + 1) - 2;

//     std::random_device rd; // obtain a random number from hardware
//     std::mt19937 gen(rd()); // seed the generator - Mersenne Twister
//     std::uniform_int_distribution<> distr(lower_bound, upper_bound); // define the range
//     return distr(gen);
// }

// // Helper function: generate zero or one (in string format)
// std::string CryptoTree::randomBinary()
// {
//     // Generate the random number
//     int num = ((int)rand() % 2);
//     return std::to_string(num);
// }


// std::string CryptoTree::generatePath() {
//     std::srand(time(NULL));
//     std::string path = "";
//     for (int i=0; i<this->depth; ++i) {
//         path += randomBinary();
//     }
//     return path;
// }

// std::string CryptoTree::hashPath(int depth, std::vector<bytes*> content);

void CryptoTree::insert();

void CryptoTree::senderUpdateTree();

void CryptoTree::receiverUpdateTree();


// std:string CryptoTree::binaryHash(std::string const &byte_hash) {
//     std::string binary_hash = "";
//     for (char const &c: byte_hash) {
//         binary_hash += std::bitset<8>(c).to_string();
//     }
//     return binary_hash;
// }


#include "updatable_private_set_intersection/protocol_party.h"
#include "updatable_private_set_intersection/crypto_tree.h"
#include "updatable_private_set_intersection/crypto_node.h"
#include "updatable_private_set_intersection/crypto/context.h"
#include "updatable_private_set_intersection/crypto/ec_commutative_cipher.h"
#include "updatable_private_set_intersection/crypto/paillier.h"

namespace updatable_private_set_intersection {

ProtocolParty::ProtocolParty() {};

ProtocolParty::ProtocolParty(int id, ProtocolParams params) {
    this->id = id;
    this->params = params;
};

} // namespace updatable_private_set_intersection

#ifndef ProtocolParty_H
#define ProtocolParty_H

#include "updatable_private_set_intersection/crypto_tree.h"
#include "updatable_private_set_intersection/crypto_node.h"
#include "updatable_private_set_intersection/crypto/context.h"
#include "updatable_private_set_intersection/crypto/ec_commutative_cipher.h"
#include "updatable_private_set_intersection/crypto/paillier.h"

namespace updatable_private_set_intersection {

// typedef std::tuple<ECPoint, BigNum> EncryptedElement;
typedef std::tuple<std::string, int> EncryptedElement;

struct ProtocolParams {
    int node_size;
    int stash_size;
    int functionality; // 0 - regular PSI; 1 - cardinality; 2 - sum; 3 - secret shares
    // ElGamal encryption/EC commutative cipher
    BigNum my_pub_key;
    BigNum their_pubkey;
    BigNum my_priv_key;
    // Paillier encryption
    BigNum shared_pub_key;
    BigNum my_shared_priv_key;
};

class ProtocolParty
{
    private:
        // ID (can only be 0 and 1)
        // P_0, P_1
        int id;
        // Each party holds a crypto tree
        CryptoTree crypto_tree;
        // Parameter variable
        ProtocolParams params;
        // TODO: Potential connection info???

    public:
        /// @brief Protocol Party Construction
        ProtocolParty();

        ProtocolParty(int id, ProtocolParams params);


};

}

#endif
